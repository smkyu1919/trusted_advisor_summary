#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Trusted Advisor 체크 결과를 단일 시트(All)로 출력
- Category 순 정렬
- 각 체크 행에 '리소스 값' 컬럼 추가 (정상 블록은 출력하지 않음)
- '최종 상태'는 정상/주의/경고/미확인 요약
- 제외(isSuppressed=True)는 카운트만 반영
- '소스 종류' 컬럼 (키워드 기반 추정)

rv5m.6 (2025-10-22)
- 우선순위 재정렬(헤더 기준, 모두 '행 메타 헤더 값'):
  1) ResourceId / Resource Id / Resource (값이 '행 resourceId'와 일치할 경우는 표시 패스)
  2) Identifier / Name (값이 '포함'된 헤더, 헤더순서 우선)
  3) Instance (값이 '포함'된 헤더, type/class 제외, ARN 허용)
  4) Strong (기존 STRONG_META_KEYS_ORDER)
  5) 체크 전용 키 (예: NAT Gateway AZ Independence → NAT ID)
  6) Recommended Resource Summary (정확 일치)
  7) 연관성 묶음 조합 (Region | Reason)
  8) 전체 조합 (난수/리전/AZ/타입토큰 제외)

- pick_id_name_tab(): Identifier/Name 전용 스캐너(헤더순서 우선)
- pick_instance_tab(): Instance 전용 스캐너(type/class 헤더 제외)
- 1순위: 행 resourceId와 동일한 값은 표시용에서 패스(난수/원시 ID 노출 방지)
- Recommended Resource Summary 안전 필터 보강
- 환경성 컬럼(region/az) 및 값(region/AZ/인스턴스클래스/난수토큰) 제외 정책 유지
"""

import os
import sys
import time
import re
from typing import Dict, List, Tuple, DefaultDict
from collections import defaultdict

import boto3
import botocore
import pandas as pd
from openpyxl.styles import Alignment
from openpyxl.utils import get_column_letter


# ───────────────────────────────────────────────────────────────────────────── 시작
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# 접근 정보, 기본 셋팅 값
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# ───────────────────────────────────────────────────────────────────────────── 시작


VERSION = "rv5m.6-2025-10-22-045"
OUTPUT_XLSX = "trusted_advisor_checks.xlsx"

LANGUAGE = "en"              # en 또는 ja
SUPPORT_REGION = "us-east-1" # TA API 고정

# ⚠️ 운영에서는 하드코드 자격증명 사용 지양(사용자 제공 코드 유지)
session = boto3.Session(
    aws_access_key_id=" ",
    aws_secret_access_key=" ",
    region_name=SUPPORT_REGION,
)

PRETTY_PILLAR: Dict[str, str] = {
    "cost_optimizing": "Cost Optimization",
    "cost_optimization": "Cost Optimization",
    "performance": "Performance",
    "security": "Security",
    "fault_tolerance": "Fault Tolerance",
    "operational_excellence": "Operational Excellence",
    "service_limits": "Service Limits",
    "service_quotas": "Service Limits",
}

STATUS_MAP_FINAL = {"error": "경고", "warning": "주의", "ok": "정상"}

def pretty_pillar_name(raw: str) -> str:
    if not raw:
        return "Unknown"
    raw_lc = raw.strip().lower()
    return PRETTY_PILLAR.get(raw_lc, raw_lc.replace("_", " ").title())

def backoff_sleep(i: int):
    time.sleep(min(2 ** i, 10))

# ───────────────────────────────────────────────────────────────────────────── 끝
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# 접근 정보, 기본 셋팅 값
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# 기본 정보
# ───────────────────────────────────────────────────────────────────────────── 끝











# ───────────────────────────────────────────────────────────────────────────── 시작
# 패턴/유틸
# 패턴/유틸
# 패턴/유틸
# 패턴/유틸
# 패턴/유틸
# ───────────────────────────────────────────────────────────────────────────── 시작

# ── 디버그 스위치 ──
TA_DEBUG = os.getenv("TA_DEBUG", "0") == "1"   # 1이면 상세 디버그 출력
TA_DEBUG_CHECK = os.getenv("TA_DEBUG_CHECK", "")  # 특정 체크명 필터(정규식). 예: "Idle Load Balancers|Amazon RDS Idle DB Instances"
TA_DEBUG_MAX = int(os.getenv("TA_DEBUG_MAX", "50"))  # 행별 최대 출력 줄수 안전장치

ARN_RE = re.compile(r"^arn:(aws|aws-cn|aws-us-gov):([a-z0-9\-]+):([a-z0-9\-]*):(\d{12})?:(.+)$")
LAMBDA_FN_ARN_RE = re.compile(r"arn:[^:]+:lambda:[^:]+:\d{12}:function[:/][A-Za-z0-9-_]+(?::[A-Za-z0-9\-\$._+]+)?")

VOL_RE = re.compile(r"\bvol-[0-9a-fA-F]{8,}\b")
I_RE   = re.compile(r"\bi-[0-9a-fA-F]{8,}\b")
SG_RE  = re.compile(r"\bsg-[0-9a-fA-F]{8,}\b")
ENI_RE = re.compile(r"\beni-[0-9a-fA-F]{8,}\b")
SNAP_RE= re.compile(r"\bsnap-[0-9a-fA-F]{8,}\b")

TG_PATH_RE  = re.compile(r"\btargetgroup/[A-Za-z0-9-]+/[0-9a-fA-F]{6,}\b")
ALB_PATH_RE = re.compile(r"\bapp/[A-Za-z0-9-]+/[0-9a-fA-F]{6,}\b")
NLB_PATH_RE = re.compile(r"\bnet/[A-Za-z0-9-]+/[0-9a-fA-F]{6,}\b")

RDS_ARN_RE  = re.compile(r"arn:[^:]+:rds:[^:]+:\d{12}:(?:db|cluster):[A-Za-z0-9-]+")
KMS_ARN_RE  = re.compile(r"arn:[^:]+:kms:[^:]+:\d{12}:(?:key|alias)/[A-Za-z0-9/_\-]+")
IAM_ARN_RE  = re.compile(r"arn:[^:]+:iam::\d{12}:(?:role|user|group|policy)/[A-Za-z0-9+=,.@\-_/]+")

DDB_ARN_RE  = re.compile(r"arn:[^:]+:dynamodb:[^:]+:\d{12}:table/[A-Za-z0-9_.\-]+")
SNS_ARN_RE  = re.compile(r"arn:[^:]+:sns:[^:]+:\d{12}:[A-Za-z0-9_.\-]+")
SQS_ARN_RE  = re.compile(r"arn:[^:]+:sqs:[^:]+:\d{12}:[A-Za-z0-9_.\-]+")
ECR_ARN_RE  = re.compile(r"arn:[^:]+:ecr:[^:]+:\d{12}:repository/[A-Za-z0-9/_\-]+")
EKS_ARN_RE  = re.compile(r"arn:[^:]+:eks:[^:]+:\d{12}:cluster/[A-Za-z0-9._\-]+")
ECS_ARN_RE  = re.compile(r"arn:[^:]+:ecs:[^:]+:\d{12}:(?:service|cluster)/[A-Za-z0-9/_\-]+")
CFN_DISTR_ID_RE = re.compile(r"\bE[A-Z0-9]{12}\b")

ELASTICACHE_RE = re.compile(r"\b(arn:[^:]+:elasticache:[^:]+:\d{12}:.+|cache\.[a-z0-9\-]+|[A-Za-z0-9\-]*cache[A-Za-z0-9\-]*)\b")
REDSHIFT_ARN_RE= re.compile(r"arn:[^:]+:redshift:[^:]+:\d{12}:(?:cluster|dbname):[A-Za-z0-9\-]+")

OPENSEARCH_ARN_RE = re.compile(r"arn:[^:]+:(?:es|opensearch):[^:]+:\d{12}:domain/[A-Za-z0-9\-]+")
ROUTE53_HOSTEDZONE_RE = re.compile(r"/hostedzone/[A-Z0-9]+")
ROUTE53_ZONE_NAME_RE  = re.compile(r"^[A-Za-z0-9.-]+\.[A-Za-z]{2,}$")

BUCKETISH_RE = re.compile(r"^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$")
HUMAN_NAME_RE = re.compile(r"^[A-Za-z0-9][A-Za-z0-9._\-\/]{2,200}$")
NOISE_TOKEN_RE = re.compile(r"^[A-Za-z0-9\-_]{24,}$")

# RDS DB 인스턴스 식별자: 소문자/숫자/하이픈, 최대 63자
RDS_IDENTIFIER_RE = re.compile(r"^[a-z][a-z0-9-]{0,62}$")
AZ_RE = re.compile(r"^(?:us|ap|eu|me|af|sa|ca)-[a-z]+-\d+[a-z]$", re.I)

# NAT GW ID 형태: nat- + 8~32자리 hex
NAT_ID_RE = re.compile(r"\bnat-[0-9a-f]{8,32}\b", re.I)

REGION_RE = re.compile(
    r"^(?:us|ap|eu|me|af|sa|ca)-(?:north|south|east|west|northeast|southeast|central|southwest|northwest)\-\d+$|^global$",
    re.I,
)

# ▼ EC2/RDS 등 인스턴스 클래스(타입 토큰)
INSTANCE_CLASS_RE = re.compile(
    r"^(?:db\.[a-z0-9.]+|"
    r"(?:[cmrtgipdhnxz][0-9a-z]?)\.(?:nano|micro|small|medium|large|xlarge|[2-9]xlarge)|"
    r"[a-z][0-9][a-z]?\.[a-z0-9.]+)$",
    re.I,
)

TOP_RESOURCE_KEYS_EXACT = ("resource id", "resourceid", "resource")

# ───────────────────────────────────────────────────────────────────────────── 끝
# 패턴/유틸
# 패턴/유틸
# 패턴/유틸
# 패턴/유틸
# 패턴/유틸
# ───────────────────────────────────────────────────────────────────────────── 끝















# ───────────────────────────────────────────────────────────────────────────── 시작
# 디버그
# 디버그
# 디버그
# 디버그
# 디버그
# (디버그) 상단
# 디버그
# 디버그
# 디버그
# 디버그
# 디버그
# ───────────────────────────────────────────────────────────────────────────── 시작

# ── 콘솔 트레이스: 관심 체크만 출력 ──
TRACE_CHECKS = {
    "idle load balancers",
    "amazon rds idle db instances",
}

def _lc(s: str) -> str:
    return (s or "").strip().lower()

def _trace_on(check_name: str) -> bool:
    return _lc(check_name) in TRACE_CHECKS

def _log(*args):
    try:
        print("[TRACE]", *args)
    except Exception:
        pass

def _scan_tokens(meta_headers: List[str], meta_map: Dict[str, str], tokens: Tuple[str, ...], ban_substr: Tuple[str, ...]) -> List[Tuple[str, str, str]]:
    """
    헤더 순서대로 tokens '포함' 매칭. (k=정규화 헤더)
    반환: [(k, value, reason)]
    """
    out: List[Tuple[str, str, str]] = []
    TOKENS_LC = tuple(t.lower() for t in tokens)
    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if not k:
            continue
        if any(tok in k for tok in TOKENS_LC):
            if any(b in k for b in ban_substr):
                out.append((k, meta_map.get(k, ""), "reject: banned header(type/class)"))
                continue
            v = (meta_map.get(k, "") or "").strip()
            if not v:
                out.append((k, v, "reject: empty"))
                continue
            if _is_region_like(v) or AZ_RE.match(v):
                out.append((k, v, "reject: region/az-like value"))
                continue
            # ▶ 이름/식별자 헤더일 때는 노이즈 토큰이라도 허용
            if _is_noise(v) and not _is_namey_header(k):
                out.append((k, v, "reject: noise token"))
                continue
            if INSTANCE_CLASS_RE.match(v):
                out.append((k, v, "reject: instance class token"))
                continue
            if ARN_RE.match(v):
                out.append((k, v, "accept: arn"))
                continue
            if RDS_IDENTIFIER_RE.match(v):
                out.append((k, v, "accept: rds identifier"))
                continue
            out.append((k, v, "accept: generic"))
    return out


def _trace_candidates(check_name: str, meta_headers: List[str], meta_map: Dict[str, str]) -> None:
    if not _trace_on(check_name):
        return
    _log("=" * 72)
    _log("CHECK:", check_name)
    for i, h in enumerate(meta_headers or []):
        k = _normalize(_s(h))
        _log(f"[H{i:02d}] {h!r} → {k!r} => {meta_map.get(k, '')!r}")

    # 2순위: Identifier/Name
    name_tokens = (
        "identifier", "name", "이름", "display name",
        "db instance name", "db instance identifier", "db identifier", "database name", "db instance",
        "load balancer name", "load balancer", "elb name", "alb name", "nlb name",
        "cluster name", "cluster identifier", "resource name", "hosted zone name",
        "table name", "queue name", "topic name", "repository name",
    )
    rows2 = _scan_tokens(meta_headers, meta_map, name_tokens, ban_substr=(" type", "type", "class"))
    if rows2:
        _log("2순위 후보(Name/Identifier):")
        for k, v, why in rows2:
            _log("  -", k, "=>", v, f"({why})")
    else:
        _log("2순위 후보(Name/Identifier): 없음")

    # 3순위: Instance
    inst_tokens = ("instance", "target group")
    rows3 = _scan_tokens(meta_headers, meta_map, inst_tokens, ban_substr=(" type", "type", "class"))
    if rows3:
        _log("3순위 후보(Instance):")
        for k, v, why in rows3:
            _log("  -", k, "=>", v, f"({why})")
    else:
        _log("3순위 후보(Instance): 없음")


# (디버그) 특정 체크의 헤더/값 출력
# def _debug_print_meta_for_rds_backups(check_name: str, meta_headers: List[str], meta_vals: List[str], rid: str, st: str):
#     if "rds backups" not in (check_name or "").lower():
#         return
#     try:
#         pairs = []
#         for i, (h, v) in enumerate(zip(meta_headers or [], meta_vals or [])):
#             pairs.append(f"  [{i:02d}] {h!r} => {v!r}")
#         print("[DEBUG][RDS Backups] resourceId =", rid)
#         print("[DEBUG][RDS Backups] status     =", st)
#         print("[DEBUG][RDS Backups] meta map:")
#         print("\n".join(pairs))
#         print("-" * 60)
#     except Exception as e:
#         print("[DEBUG][RDS Backups] print error:", e)

# ───────────────────────────────────────────────────────────────────────────── 하단
# 디버그
# 디버그
# 디버그
# 디버그
# 디버그
# (디버그) 하단
# 디버그
# 디버그
# 디버그
# 디버그
# 디버그
# ───────────────────────────────────────────────────────────────────────────── 하단










# ───────────────────────────────────────────────────────────────────────────── 시작
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# 스캐너 / 조건식
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# ───────────────────────────────────────────────────────────────────────────── 시작

# ─────────────────────────────────────────────────────────────────────────────
# 보조 판정기
# ─────────────────────────────────────────────────────────────────────────────


def _is_human_friendly_for_name(s: str, *, header_key: str = "") -> bool:
    s = _s(s).strip()
    if not s:
        return False
    if s.lower().startswith("arn:"):
        return False
    if _is_region_like(s):
        return False
    if INSTANCE_CLASS_RE.match(s):  # db.t3.micro 등
        return False

    k = _normalize(_s(header_key))
    if ("name" in k) or ("이름" in k):
        if RDS_IDENTIFIER_RE.match(s):
            return True

    if _is_noise(s):
        return False
    return True

def _is_iam_access_analyzer_check(name: str) -> bool:
    return "iam access analyzer" in (name or "").lower()

def _is_iam_ak_rotation_check(name: str) -> bool:
    return "access key rotation" in (name or "").lower()

def _is_password_policy_check(name: str) -> bool:
    """체크명에 'password policy'가 포함되면 True"""
    return "password policy" in (name or "").lower()


def _is_zone_balance_check(name: str) -> bool:
    """체크명에 'Zone Balance'가 포함되면 True"""
    return "zone balance" in (name or "").lower()

def _is_ecs_check(name: str) -> bool:
    """체크명에 'ECS'가 포함되면 True"""
    return "ecs" in (name or "").lower()

def _is_ebs_check(name: str) -> bool:
    """체크명에 'EBS'가 포함되면 True"""
    return "ebs" in (name or "").lower()

def _is_namey_header(header_lc: str) -> bool:
    """
    '이름/식별자' 성격의 헤더면 True.
    이런 헤더는 값이 해시형/길어도 노이즈로 보지 않는다.
    """
    k = (header_lc or "").strip().lower()
    NAMEY_KEYS = (
        "name", "이름", "identifier", "display name",
        "db instance name", "db instance identifier", "db identifier", "database name", "db instance",
        "load balancer name", "load balancer", "elb name", "alb name", "nlb name",
        "cluster name", "cluster identifier",
        "resource name", "hosted zone name",
        "table name", "queue name", "topic name", "repository name",
        "target group"
    )
    return any(tok in k for tok in NAMEY_KEYS)

def _is_purchase_reco_check(name: str) -> bool:
    """체크명에 'Purchase Recommendations'가 포함되면 True"""
    return "purchase recommendations" in (name or "").lower()


def _is_nataz_header(key_lc: str) -> bool:
    """'nat availability zone'같은 AZ성 헤더인지 판별"""
    k = (key_lc or "").strip().lower()
    return ("availability zone" in k) or (k.endswith(" az")) or (" az " in k)

def _is_nat_check(name: str) -> bool:
    return "nat" in (name or "").lower()

def _s(v) -> str:
    return v if isinstance(v, str) else ("" if v is None else str(v))

def _normalize(s: str) -> str:
    return (s or "").strip().lower()

def _last_token(s: str) -> str:
    s = _s(s)
    if not s:
        return ""
    t = re.split(r"[/:]", s)
    return t[-1] if t else s

def _is_region_like(s: str) -> bool:
    s = _s(s).strip()
    if not s:
        return False
    return bool(REGION_RE.match(s))

def _is_noise(s: str) -> bool:
    s = _s(s)
    if not s:
        return False
    # 표준 패턴/ARN/경로는 노이즈 아님
    if ARN_RE.match(s) or VOL_RE.search(s) or I_RE.search(s) or SG_RE.search(s) or ENI_RE.search(s) or SNAP_RE.search(s):
        return False
    if TG_PATH_RE.search(s) or ALB_PATH_RE.search(s) or NLB_PATH_RE.search(s):
        return False
    return bool(NOISED := NOISE_TOKEN_RE.match(s))

def _arn_resource_part(arn: str) -> str:
    m = ARN_RE.match(_s(arn))
    if not m:
        return _s(arn)
    return m.group(5) or ""

def _shorten_arn_generic(arn: str) -> str:
    arn = _s(arn)
    res = _arn_resource_part(arn)

    if IAM_ARN_RE.match(arn):
        return res.split("/", 1)[1] if "/" in res else res
    if LAMBDA_FN_ARN_RE.search(arn):
        return _last_token(res)
    if res.startswith("table/"):
        return res.split("/", 1)[1]
    if ":sns:" in arn or ":sqs:" in arn:
        return _last_token(res)
    if ":ecr:" in arn and res.startswith("repository/"):
        return res.split("/", 1)[1]
    if ":ecs:" in arn and (res.startswith("service/") or res.startswith("cluster/")):
        return res.split("/", 1)[1]
    if ":eks:" in arn and res.startswith("cluster/"):
        return res.split("/", 1)[1]
    if ":rds:" in arn and (res.startswith("db:") or res.startswith("cluster:")):
        return res.split(":", 1)[1]
    if ":kms:" in arn and (res.startswith("key/") or res.startswith("alias/")):
        return res.split("/", 1)[1]
    return _last_token(res)

def _shorten_arn(arn: str) -> str:
    return _shorten_arn_generic(arn)

def _dict_from_meta(meta_headers: List[str], meta_values: List[str]) -> Dict[str, str]:
    d = {}
    for h, v in zip(meta_headers or [], meta_values or []):
        d[_normalize(_s(h))] = _s(v).strip()
    return d

def _pick_first(rx: re.Pattern, texts: List[str]) -> str:
    for t in texts or []:
        ts = _s(t)
        m = rx.search(ts)
        if m:
            return m.group(0)
    return ""

def _has_lambda_version(texts: List[str]) -> str:
    for v in texts or []:
        sv = _s(v)
        if LAMBDA_FN_ARN_RE.search(sv) and (":$" in sv or sv.endswith(":$LATEST")):
            return sv
    return ""

def _is_human_name(s: str) -> bool:
    s = _s(s)
    if _is_noise(s) or _is_region_like(s):
        return False
    if INSTANCE_CLASS_RE.match(s):
        return False
    return bool(HUMAN_NAME_RE.match(s)) and not (VOL_RE.search(s) or I_RE.search(s))

def pick_nat_id_preferred(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    NAT 계열 체크에서만 사용.
    meta_headers '순서'대로 스캔하여
    - 헤더가 'nat id' 또는 'nat gateway id' 면 그 값을 반환.
    - 값 필터: 공백/Region/AZ/InstanceClass 배제 (노이즈 필터 레벨은 건드리지 않음)
    - 값이 NAT_ID_RE에 맞으면 그대로 반환, 아니어도 위 배제조건만 넘기면 허용.
    """
    TARGET_KEYS = ("nat id", "nat gateway id")
    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if k in TARGET_KEYS:
            v = (meta_map.get(k, "") or "").strip()
            if not v:
                continue
            # 값 안전 필터 (노이즈 레벨 변경 없음)
            if _is_region_like(v) or AZ_RE.match(v) or INSTANCE_CLASS_RE.match(v):
                continue
            # NAT ID 패턴이면 그대로
            m = NAT_ID_RE.search(v)
            if m:
                return m.group(0)
            # 패턴이 아니어도(예: ARN, 라벨 변형) 위 배제만 통과하면 사용
            if ARN_RE.match(v):
                return v
            return v
    return ""

def pick_ebs_volume_id_preferred(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    EBS 계열 체크에서만 사용.
    meta_headers '순서'대로 스캔하여 헤더가 'volume id'면 그 값을 우선 반환.
    - 값 필터: 공백/Region/AZ/InstanceClass 배제 (노이즈 필터 레벨은 건드리지 않음)
    - 값이 'vol-...' 패턴이면 그대로 반환, 아니어도 위 배제조건만 넘기면 허용.
    """
    TARGET_KEY = "volume id"
    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if k == TARGET_KEY:
            v = (meta_map.get(k, "") or "").strip()
            if not v:
                continue
            # 안전 필터 (레벨 변경 없음)
            if _is_region_like(v) or AZ_RE.match(v) or INSTANCE_CLASS_RE.match(v):
                continue
            # 전형적인 EBS 볼륨 ID면 그대로 반환
            m = VOL_RE.search(v)
            if m:
                return m.group(0)
            # 패턴이 아니어도(예: 포맷 변형) 유효하면 사용
            return v
    return ""

def pick_ecs_resource_tail(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    ECS 계열 체크에서만 사용.
    meta_headers 순서대로 'resource' / 'resource id' / 'resourceid' 헤더를 찾아
    값이 ECS ARN이면, 마지막 '/' 뒤의 문자열 전체(예: 'aaa:1')를 반환.
    - 기존 shorten 로직은 쓰지 않음(':' 기준 잘림 방지).
    - 값이 없거나 ARN이 아니면 스킵하고 패스.
    """
    TARGET_KEYS = ("resource", "resource id", "resourceid")
    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if k in TARGET_KEYS:
            v = (meta_map.get(k, "") or "").strip()
            if not v:
                continue
            if ARN_RE.match(v) and ":ecs:" in v:
                # arn의 resource part: e.g. 'task-definition/aaa:1'
                res_part = _arn_resource_part(v)
                if "/" in res_part:
                    tail = res_part.split("/")[-1].strip()
                    if tail:
                        return tail     # 예: 'aaa:1'
            # ARN이 아니면 패스(다음 우선순위로 진행)
    return ""

def pick_zone_balance_all_values(meta_headers: List[str], meta_vals: List[str]) -> str:
    """
    Zone Balance 계열: 각 행의 '모든 메타데이터 값'을 원래 순서대로
    두 칸 공백으로 연결해서 반환한다.
    - 빈 값은 건너뛰고, 나머지는 가공/축약 없이 그대로 사용.
    - 헤더명은 포함하지 않고 '값'만 나열.
    """
    values: List[str] = []
    for v in (meta_vals or []):
        vv = (v or "").strip()
        if vv:
            values.append(vv)
    return "  ".join(values) if values else ""

def pick_password_policy_all_kv(meta_headers: List[str], meta_vals: List[str]) -> str:
    """
    Password Policy 계열: 각 행의 모든 메타데이터를
    '헤더: 값' 형태로 두 칸 공백으로 연결해서 반환.
    - 빈 값은 건너뜀
    - 원본 헤더 표기(meta_headers) 보존
    """
    parts: List[str] = []
    for h, v in zip(meta_headers or [], meta_vals or []):
        vv = (v or "").strip()
        if not vv:
            continue
        hh = str(h or "").strip()
        parts.append(f"{hh}: {vv}")
    return "  ".join(parts) if parts else ""

def pick_region_only(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    IAM Access Analyzer 전용: Region만 반환.
    meta_headers 순서/동의어를 고려해 region 값을 찾아 반환.
    """
    # 기존 유틸 재사용 (동의어 우선 탐색)
    v = _get_by_synonyms_in_order(meta_headers, meta_map, ["region", "aws region", "location"])
    return (v or "").strip()

def pick_iam_user_plus_reason(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    IAM Access Key Rotation 전용: 'IAM User' + 'Reason' 를 두 칸 공백으로 연결하여 반환.
    - 정확키 우선 → 부분일치 보조
    """
    def _find_value(keys_exact: Tuple[str, ...], token_partial: str) -> str:
        # 1) 정확 일치 키 우선
        for k in keys_exact:
            v = meta_map.get(k)
            if v:
                vv = (v or "").strip()
                if vv:
                    return vv
        # 2) 부분일치 (헤더에 토큰이 포함되면)
        for h in (meta_headers or []):
            kl = _normalize(_s(h))
            if token_partial in kl:
                v = (meta_map.get(kl, "") or "").strip()
                if v:
                    return v
        return ""

    user = _find_value(("iam user",), "iam user")
    if not user:
        user = _find_value(("user", "user name"), "user")  # 보조

    reason = _find_value(("reason",), "reason")

    parts = [p for p in [user, reason] if p]
    return "  ".join(parts) if parts else ""



# ─────────────────────────────────────────────────────────────────────────────
# ResourceId → 사람친화 (서비스 공통)
# ─────────────────────────────────────────────────────────────────────────────
def display_from_resource_id(resource_id: str, meta_vals: List[str]) -> str:
    rid = _s(resource_id).strip()
    if not rid or _is_noise(rid) or _is_region_like(rid):
        return ""

    for rx in [VOL_RE, I_RE, SG_RE, ENI_RE, SNAP_RE]:
        m = rx.search(rid)
        if m:
            return m.group(0)

    for rx in [TG_PATH_RE, ALB_PATH_RE, NLB_PATH_RE]:
        m = rx.search(rid)
        if m:
            segs = m.group(0).split("/")
            return segs[1] if len(segs) >= 2 else m.group(0)

    if LAMBDA_FN_ARN_RE.search(rid):
        if ":$" in rid or rid.endswith(":$LATEST"):
            return rid
        if ARN_RE.match(rid):
            return _shorten_arn(rid)
        return rid

    if ARN_RE.match(rid):
        full = _has_lambda_version(meta_vals)
        if full:
            return full
        return _shorten_arn(rid)

    if BUCKETISH_RE.match(rid) or _is_human_name(rid) or ("/" in rid and _is_human_name(rid)):
        return rid

    return ""

# ─────────────────────────────────────────────────────────────────────────────
# Strong 메타 키(리소스 이름/ID급)
# ─────────────────────────────────────────────────────────────────────────────
STRONG_META_KEYS_ORDER = [
    "bucket name",
    "role name", "user name", "group name", "policy name",
    "iam role", "iam user", "iam group", "iam policy",
    "function name", "lambda function", "function",
    "service name", "cluster name", "task definition", "workload",
    "load balancer name", "elb name", "alb name", "nlb name", "target group",
    "queue name", "topic name",
    "table name", "db identifier", "db id", "cluster id", "database name",
    "repository name",
    "distribution id",
    "domain name", "hosted zone name", "hosted zone id",
    "resource name", "name", "display name", "id",
    "instance id", "volume id", "volume arn", "security group id", "vpc id",
    "cache cluster id", "cache node type",
]

def pick_strong_meta_id(meta_map: Dict[str, str], meta_vals: List[str]) -> str:
    for key in STRONG_META_KEYS_ORDER:
        v = meta_map.get(key)
        if not v or _is_noise(v) or _is_region_like(v):
            continue
        if ARN_RE.match(v):
            if LAMBDA_FN_ARN_RE.search(v) and (":$" in v or v.endswith(":$LATEST")):
                return v
            return _shorten_arn(v)
        if any(rx.search(v) for rx in [VOL_RE, I_RE, SG_RE, ENI_RE, SNAP_RE]):
            return v
        for rx in [TG_PATH_RE, ALB_PATH_RE, NLB_PATH_RE]:
            m = rx.search(v)
            if m:
                segs = m.group(0).split("/")
                return segs[1] if len(segs) >= 2 else m.group(0)
        if CFN_DISTR_ID_RE.match(v):
            return v
        if BUCKETISH_RE.match(v) or _is_human_name(v):
            return v

    mvals = [_s(x) for x in (meta_vals or []) if _s(x) and not _is_noise(x) and not _is_region_like(x)]

    for rx in [IAM_ARN_RE, RDS_ARN_RE, KMS_ARN_RE, DDB_ARN_RE, SNS_ARN_RE, SQS_ARN_RE,
               ECR_ARN_RE, EKS_ARN_RE, ECS_ARN_RE, OPENSEARCH_ARN_RE, REDSHIFT_ARN_RE]:
        hit = _pick_first(rx, mvals)
        if hit:
            return _shorten_arn(hit)

    for rx in [TG_PATH_RE, ALB_PATH_RE, NLB_PATH_RE]:
        hit = _pick_first(rx, mvals)
        if hit:
            segs = hit.split("/")
            return segs[1] if len(segs) >= 2 else hit

    hit = _has_lambda_version(mvals)
    if hit:
        return hit
    for val in mvals:
        if LAMBDA_FN_ARN_RE.search(val):
            return _shorten_arn(val)

    hit = _pick_first(CFN_DISTR_ID_RE, mvals)
    if hit:
        return hit

    for val in mvals:
        if ROUTE53_ZONE_NAME_RE.match(val):
            return val

    for val in mvals:
        if BUCKETISH_RE.match(val) and "." not in val:
            return val

    for val in mvals:
        if _is_human_name(val):
            return val

    return ""

# ─────────────────────────────────────────────────────────────────────────────
# 새 2순위: Identifier/Name/Instance 통합 스캐너
# ─────────────────────────────────────────────────────────────────────────────
def pick_id_name_instance_tab(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    2순위: Identifier/Name/Instance '포함' 헤더를 meta_headers '순서대로' 스캔.
    - 'type' / 'class' 포함 헤더는 제외
    - 값 필터: Region/AZ/InstanceClass/Noise 토큰 제외
    - ARN은 그대로 허용(축약하지 않음)
    - RDS 식별자 패턴 허용
    """
    KEY_TOKENS = (
        # 기본 키워드
        "identifier", "name", "이름", "instance",
        # 로드밸런서/타깃/식별자 변형
        "load balancer name", "elb name", "alb name", "nlb name",
        "load balancer", "target group",
        # rds/db 계열
        "db instance name", "db instance identifier",
        "db instance", "db identifier",
        "rds instance", "database", "cluster identifier", "cluster name"
    )

    def _accept(v: str) -> str:
        v = (v or "").strip()
        if not v:
            return ""
        if _is_region_like(v) or AZ_RE.match(v) or INSTANCE_CLASS_RE.match(v) or _is_noise(v):
            return ""
        if ARN_RE.match(v):
            return v  # 축약하지 않음
        if RDS_IDENTIFIER_RE.match(v):
            return v
        return v

    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if any(tok in k for tok in KEY_TOKENS):
            if "type" in k or "class" in k:
                continue
            v = meta_map.get(k, "")
            acc = _accept(v)
            if acc:
                return acc
    return ""


# ─────────────────────────────────────────────────────────────────────────────
# 1순위: 헤더 Resource* 가 행 resourceId와 '값 일치'하는지 판정(표시에는 사용 X)
# ─────────────────────────────────────────────────────────────────────────────
def _resource_header_same_as_row_resource_id(meta_headers: List[str], meta_map: Dict[str, str], resource_id: str) -> bool:
    """
    헤더가 'resourceid' / 'resource id' / 'resource' 이고,
    '값'이 행 resourceId와 '일치'하는지 확인 (난수토큰 그대로 노출 방지)
    """
    rid = (resource_id or "").strip()
    if not rid:
        return False
    TARGET_KEYS = ("resourceid", "resource id", "resource")
    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if k in TARGET_KEYS:
            if (meta_map.get(k, "").strip() == rid):
                return True
    return False

# ─────────────────────────────────────────────────────────────────────────────
# 체크 전용/조합 빌더
# ─────────────────────────────────────────────────────────────────────────────

# 체크 전용/조합 빌더 (보강된 NAT 규칙)
CHECK_TO_KEYS: List[Tuple[re.Pattern, List[str]]] = [
    (
        re.compile(
            r"\bnat(\s*-\s*|\s+)?gateway\b.*\b(az|availability\s*zone)\b.*\b(independence|redundan|separate|multi-az)?\b",
            re.I
        ),
        [
            "nat id", "nat gateway id", "nat-gateway id", "nat gateway identifier",
            "nat gateway arn", "nat gateway", "nat-gateway", "natgw id", "natgw"
        ],
    ),
]




def pick_check_specific(check_name: str, meta_map: Dict[str, str], meta_headers: List[str], meta_vals: List[str]) -> str:
    """
    체크명과 매칭되면 전용 키 우선 탐색 → 실패 시 값 전체에서 패턴 스캔.
    AZ/Region/타입/노이즈 등은 필터.
    """
    cn = (check_name or "")
    for pat, want_keys in CHECK_TO_KEYS:
        if not pat.search(cn):
            continue

        # 1) 라벨 기반 탐색 (부분일치 허용)
        for want in want_keys:
            want_lc = (want or "").strip().lower()
            for k, v in meta_map.items():
                if want_lc in (k or ""):
                    val = (v or "").strip()
                    if not val:
                        continue
                    if _is_region_like(val) or AZ_RE.match(val):
                        continue
                    if (not _is_namey_header(k)) and _is_noise(val):
                        continue
                    if INSTANCE_CLASS_RE.match(val):
                        continue
                    return val

        # 2) 라벨 변형 느슨 매칭 (언더스코어/하이픈 정규화)
        for k, v in meta_map.items():
            k2 = (k or "").replace("_", " ").replace("-", " ")
            for want in want_keys:
                if (want or "").replace("-", " ") in k2:
                    val = (v or "").strip()
                    if not val:
                        continue
                    if _is_region_like(val) or AZ_RE.match(val):
                        continue
                    if (not _is_namey_header(k)) and _is_noise(val):
                        continue
                    if INSTANCE_CLASS_RE.match(val):
                        continue
                    return val

        # 3) ★ 값 전체에서 NAT ID 직접 스캔 (라벨이 애매해도 캐치)
        blob_vals: List[str] = []
        blob_vals.extend([str(v) for v in (meta_map or {}).values() if v])
        blob_vals.extend([str(v) for v in (meta_vals or []) if v])

        for v in blob_vals:
            m = NAT_ID_RE.search(v)
            if not m:
                continue
            nat_id = m.group(0)
            # 안전 필터 (형식상 AZ/Region/타입/노이즈 아님)
            if _is_region_like(nat_id) or AZ_RE.match(nat_id) or INSTANCE_CLASS_RE.match(nat_id):
                continue
            return nat_id

    return ""




# Service Limits / Quotas 동의어
SERVICE_LIMITS_SYNONYMS: Dict[str, List[str]] = {
    "region": ["region", "aws region", "location"],
    "service": ["service", "service name"],
    "limit_amount": ["limit amount", "limit value", "limit", "limit name", "quota", "quota name", "quota value"],
    "current_usage": ["current usage", "in use", "usage", "current value", "used"],
    "status": ["status", "limit status", "violation status"],
}

def _get_by_synonyms_in_order(meta_headers: List[str], meta_map: Dict[str, str], keys: List[str]) -> str:
    lh = [_normalize(_s(h)) for h in (meta_headers or [])]
    for k in keys:
        kk = _normalize(k)
        if kk in meta_map and meta_map[kk]:
            return meta_map[kk]
    for h in lh:
        for k in keys:
            if _normalize(k) in h:
                v = meta_map.get(h)
                if v:
                    return v
    return ""

def pick_id_name_tab(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    2순위: Identifier / Name 계열만 스캔 (헤더 '순서' 우선)
    - 'type' / 'class' 포함 헤더는 제외
    - 값 필터: Region/AZ/InstanceClass 제외
    - ▶ 이름/식별자 헤더는 노이즈 토큰이어도 허용 (콘솔/TA가 해시형 이름을 주는 케이스 대응)
    - ARN은 그대로 허용(축약하지 않음)
    - RDS 식별자 패턴 허용
    """
    KEY_TOKENS = (
        "identifier", "name", "이름", "display name",
        "db instance name", "db instance identifier", "db identifier", "database name", "db instance",
        "load balancer name", "load balancer", "elb name", "alb name", "nlb name",
        "cluster name", "cluster identifier", "resource name", "hosted zone name",
        "table name", "queue name", "topic name", "repository name"
    )
    TOKENS_LC = tuple(t.lower() for t in KEY_TOKENS)

    for h in (meta_headers or []):
        k = _normalize(_s(h))  # 소문자화
        if any(tok in k for tok in TOKENS_LC):
            if "type" in k or "class" in k:
                continue
            v = (meta_map.get(k, "") or "").strip()
            if not v:
                continue
            if _is_region_like(v) or AZ_RE.match(v):
                continue
            # ▶ 이름/식별자 헤더는 노이즈라도 허용
            if (not _is_namey_header(k)) and _is_noise(v):
                continue
            if INSTANCE_CLASS_RE.match(v):
                continue
            if ARN_RE.match(v):
                return v
            if RDS_IDENTIFIER_RE.match(v):
                return v
            return v  # generic 허용
    return ""


    def _accept(v: str) -> str:
        v = (v or "").strip()
        if not v:
            return ""
        if _is_region_like(v) or AZ_RE.match(v) or _is_noise(v) or INSTANCE_CLASS_RE.match(v):
            return ""
        if ARN_RE.match(v):
            return v
        if RDS_IDENTIFIER_RE.match(v):
            return v
        return v

    for h in (meta_headers or []):
        k = _normalize(_s(h))  # 소문자화
        if any(tok in k for tok in TOKENS_LC):
            if "type" in k or "class" in k:
                continue
            v = meta_map.get(k, "")
            acc = _accept(v)
            if acc:
                return acc
    return ""

def pick_instance_tab(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    3순위: Instance 계열 스캔 (헤더 '순서' 우선)
    - 'type' / 'class' 포함 헤더는 제외 (예: Instance Type 배제)
    - 값 필터: Region/AZ/InstanceClass 제외
    - ▶ Instance 헤더도 실제 식별자일 수 있어 노이즈 완화(이름형이면 허용)
    - ARN은 그대로 허용
    - RDS 식별자 패턴 허용
    """
    KEY_TOKENS = ("instance", "target group")
    TOKENS_LC = tuple(t.lower() for t in KEY_TOKENS)

    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if any(tok in k for tok in TOKENS_LC):
            if "type" in k or "class" in k:
                continue  # Instance Type / Class 확실히 배제
            v = (meta_map.get(k, "") or "").strip()
            if not v:
                continue
            if _is_region_like(v) or AZ_RE.match(v):
                continue
            # ▶ 이름/식별자 성격이면 노이즈라도 허용 (ex. 'db instance'에 실제 식별자)
            if (not _is_namey_header(k)) and _is_noise(v):
                continue
            if INSTANCE_CLASS_RE.match(v):
                continue
            if ARN_RE.match(v):
                return v
            if RDS_IDENTIFIER_RE.match(v):
                return v
            return v
    return ""


    def _accept(v: str) -> str:
        v = (v or "").strip()
        if not v:
            return ""
        if _is_region_like(v) or AZ_RE.match(v) or _is_noise(v) or INSTANCE_CLASS_RE.match(v):
            return ""
        if ARN_RE.match(v):
            return v
        if RDS_IDENTIFIER_RE.match(v):
            return v
        return v

    for h in (meta_headers or []):
        k = _normalize(_s(h))
        if any(tok in k for tok in TOKENS_LC):
            if "type" in k or "class" in k:
                continue  # Instance Type / Class 확실히 배제
            v = meta_map.get(k, "")
            acc = _accept(v)
            if acc:
                return acc
    return ""



def pick_service_limits_combo(meta_headers: List[str], meta_map: Dict[str, str], check_name: str) -> str:
    n = _normalize(check_name)
    if not any(tok in n for tok in ["service limit", "service limits", "service quota", "service quotas", "quota", "limit"]):
        return ""

    region        = _get_by_synonyms_in_order(meta_headers, meta_map, SERVICE_LIMITS_SYNONYMS["region"])
    service       = _get_by_synonyms_in_order(meta_headers, meta_map, SERVICE_LIMITS_SYNONYMS["service"])
    limit_amount  = _get_by_synonyms_in_order(meta_headers, meta_map, SERVICE_LIMITS_SYNONYMS["limit_amount"])
    current_usage = _get_by_synonyms_in_order(meta_headers, meta_map, SERVICE_LIMITS_SYNONYMS["current_usage"])
    status        = _get_by_synonyms_in_order(meta_headers, meta_map, SERVICE_LIMITS_SYNONYMS["status"])

    parts = [p for p in [region, service, limit_amount, current_usage, status] if p and not _is_noise(p)]
    parts = [p for p in parts if not _is_region_like(p) or p != region]
    return " | ".join(parts) if parts else ""

def pick_priority1_resource(meta_headers: List[str], meta_map: Dict[str, str], meta_vals: List[str], row_resource_id: str = "") -> str:
    """
    1순위: 헤더명이 ResourceId/Resource Id/Resource와 '정확히' 일치하면 그 값을 채택.
    - region/AZ/노이즈는 제외
    - 행 resourceId와 '값이 동일'하면 표시를 패스(난수/원시 ID 노출 방지)
    - ARN/EC2 ID 등은 display_from_resource_id()로 풀어 사용
    """
    for h in meta_headers or []:
        k = _normalize(_s(h))
        if k in TOP_RESOURCE_KEYS_EXACT:
            v = (meta_map.get(k) or "").strip()
            if not v:
                continue
            if row_resource_id and v.strip() == _s(row_resource_id).strip():
                continue
            if _is_region_like(v) or AZ_RE.match(v) or _is_noise(v):
                continue
            disp = display_from_resource_id(v, meta_vals)
            return disp or v
    return ""



def pick_priority2_ident_name_instance(meta_headers: List[str], meta_map: Dict[str, str], meta_vals: List[str]) -> str:
    """
    2순위: Identifier / Name / Instance (이 순서, 헤더 '포함' 매칭, 헤더순서 우선)
    - instance는 'type'/'class' 제외
    - region/AZ/노이즈/인스턴스클래스 제외
    - ARN/ID는 display_from_resource_id()로 정상화
    """
    def _accept(v: str) -> str:
        v = (v or "").strip()
        if not v or _is_region_like(v) or AZ_RE.match(v) or _is_noise(v) or INSTANCE_CLASS_RE.match(v):
            return ""
        disp = display_from_resource_id(v, meta_vals)
        return disp or v

    buckets = [
        lambda key: ("identifier" in key and "type" not in key),
        lambda key: (("name" in key) or ("이름" in key)),
        lambda key: ("instance" in key and "type" not in key and "class" not in key),
    ]

    for pred in buckets:
        for h in meta_headers or []:
            k = _normalize(_s(h))
            if pred(k):
                got = _accept(meta_map.get(k, ""))
                if got:
                    return got
    return ""


# REPLACE (기존 pick_recommendation_summary 대체)
def pick_recommendation_summary_exact(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    """
    5순위: 헤더명이 'recommended resource summary' 와 '정확히' 일치할 때만 사용.
    (contains 매칭 금지)
    """
    for h in meta_headers or []:
        k = _normalize(_s(h))
        if k == "recommended resource summary":
            v = (meta_map.get(k) or "").strip()
            if v and not _is_noise(v):
                return v
    return ""

def build_region_reason_combo(meta_map: Dict[str, str]) -> str:
    region = meta_map.get("region") or meta_map.get("aws region") or ""
    reason = meta_map.get("reason") or ""
    parts = [p for p in [region, reason] if p and not _is_noise(p)]
    if len(parts) >= 2:
        return " | ".join(parts)
    return ""

def build_full_combo(meta_headers: List[str], meta_map: Dict[str, str]) -> str:
    out: List[str] = []
    for h in meta_headers or []:
        key = _normalize(_s(h))
        v = meta_map.get(key)
        if not v:
            continue

        # 환경성/식별 불가 컬럼 제외
        if any(tok in key for tok in ["region", "az", "availability zone", "vpc", "account id", "account", "aws account"]):
            continue

        # 타입/클래스/스펙 계열 헤더 제외 (예: Instance Type, Class 등)
        if any(tok in key for tok in ["instance type", "type", "class", "size", "engine version"]):
            continue

        # 값 필터
        if _is_noise(v) or _is_region_like(v) or AZ_RE.match(v) or INSTANCE_CLASS_RE.match(v):
            continue

        out.append(v)
    return " | ".join(out) if out else ""

# ───────────────────────────────────────────────────────────────────────────── 시작
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# 스캐너 / 조건식
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# 스캐너
# ───────────────────────────────────────────────────────────────────────────── 시작



























# ───────────────────────────────────────────────────────────────────────────── 시작
# 우선순위
# 우선순위
# 우선순위
# 우선순위
# 최종 표시 문자열 생성 — ★우선순위 체인 반영★
# 우선순위
# 우선순위
# 우선순위
# 우선순위
# ───────────────────────────────────────────────────────────────────────────── 시작
def compose_display(check_name: str, meta_headers: List[str], meta_values: List[str], resource_id: str) -> str:
    """
    # 0-1) ★ EBS 전용: 체크명에 'EBS'가 포함되면 'Volume ID' 우선
    # 0-2) ★ ECS 전용: Resource/Resource Id/ResourceId가 ECS ARN이면 마지막 '/' 뒤 전체 사용
    # 1) Resource*
    # 1-1) ★ Purchase Recommendations 전용: Recommended Resource Summary 우선
    # 2) Identifier/Name
    # 2-1) ★ Zone Balance 전용: 모든 메타 값 두 칸 공백으로 나열
    # 3) Instance
    # 3-1) NAT 전용: 체크명에 NAT가 포함되면 NAT ID / Nat Gateway ID 우선
    # 3-2) Password Policy 전용: 모든 헤더:값을 두 칸 간격으로 나열
    # 3-3) ★ IAM Access Analyzer 전용: Region만 표시
    # 3-4) ★ IAM Access Key Rotation 전용: IAM User + Reason
    # 4) Strong
    # 5) 체크 전용
    # 6) Recommended Resource Summary
    # 7) Region | Reason
    # 8) 전체 조합
    """
    meta_vals = [_s(v) for v in (meta_values or []) if _s(v)]
    meta_map = _dict_from_meta(meta_headers, meta_vals)

    # if _trace_on(check_name):
    #     _trace_candidates(check_name, meta_headers, meta_map)
    #     #_log("row.resourceId:", resource_id)

    # 0-1) ★ EBS 전용: 체크명에 'EBS'가 포함되면 'Volume ID' 우선
    if _is_ebs_check(check_name):
        v0_ebs = pick_ebs_volume_id_preferred(meta_headers, meta_map)
        if v0_ebs:
            return v0_ebs

    # 0-2) ★ ECS 전용: Resource/Resource Id/ResourceId가 ECS ARN이면 마지막 '/' 뒤 전체 사용
    if _is_ecs_check(check_name):
        v0_ecs = pick_ecs_resource_tail(meta_headers, meta_map)
        if v0_ecs:
            return v0_ecs

    # 1) Resource*
    v1 = pick_priority1_resource(meta_headers, meta_map, meta_vals, row_resource_id=resource_id)
    if v1:
        # if _trace_on(check_name):
         #_log("→ PICK[1] Resource* :", v1)
        return v1
    # else:
    #     if _trace_on(check_name):
         #_log("× MISS[1] Resource*")

    # 1-1) ★ Purchase Recommendations 전용: Recommended Resource Summary 우선
    if _is_purchase_reco_check(check_name):
        v2pr = pick_recommendation_summary_exact(meta_headers, meta_map)
        if v2pr:
            return v2pr

    # 2) Identifier/Name
    v2 = pick_id_name_tab(meta_headers, meta_map)
    if v2:
        # if _trace_on(check_name):
        #   #_log("→ PICK[2] Name/Identifier :", v2)
        return v2
    # else:
    #     if _trace_on(check_name):_log("× MISS[2] Name/Identifier")

    # 2-1) ★ Zone Balance 전용: 모든 메타 값 두 칸 공백으로 나열
    if _is_zone_balance_check(check_name):
        v2z = pick_zone_balance_all_values(meta_headers, meta_vals)
        if v2z:
            return v2z

    # 3) Instance
    v3i = pick_instance_tab(meta_headers, meta_map)
    if v3i:
        # if _trace_on(check_name):
        #     #_log("→ PICK[3] Instance :", v3i)
        return v3i
    # else:
    #     if _trace_on(check_name):
    #         #_log("× MISS[3] Instance")

    # 3-1) NAT 전용: 체크명에 NAT가 포함되면 NAT ID / Nat Gateway ID 우선
    if _is_nat_check(check_name):
        v4_nat = pick_nat_id_preferred(meta_headers, meta_map)
        if v4_nat:
            return v4_nat

    # 3-2) Password Policy 전용: 모든 헤더:값을 두 칸 간격으로 나열
    if _is_password_policy_check(check_name):
        v_pp = pick_password_policy_all_kv(meta_headers, meta_vals)
        if v_pp:
            return v_pp

    # 3-3) ★ IAM Access Analyzer 전용: Region만 표시
    if _is_iam_access_analyzer_check(check_name):
        v_aa = pick_region_only(meta_headers, meta_map)
        if v_aa:
            return v_aa

    # 3-4) ★ IAM Access Key Rotation 전용: IAM User + Reason
    if _is_iam_ak_rotation_check(check_name):
        v_akr = pick_iam_user_plus_reason(meta_headers, meta_map)
        if v_akr:
            return v_akr

    # 4) Strong
    v4 = pick_strong_meta_id(meta_map, meta_vals)
    if v4:
        # if _trace_on(check_name):
        # #_log("→ PICK[4] Strong :", v4)
        return v4
    # else:
    #     if _trace_on(check_name):
    #         #_log("× MISS[4] Strong")

    # 5) 체크 전용
    v5 = pick_check_specific(check_name, meta_map, meta_headers, meta_vals)
    if v5:
        # if _trace_on(check_name):
        # #_log("→ PICK[5] CheckSpecific :", v5)
        return v5
    # else:
    #     if _trace_on(check_name):
    #         #_log("× MISS[5] CheckSpecific")

    # 6) Recommended Resource Summary
    v6 = pick_recommendation_summary_exact(meta_headers, meta_map)
    if v6:
        # if _trace_on(check_name):
        #     #_log("→ PICK[6] RecResourceSummary :", v6)
        return v6
    # else:
    #     if _trace_on(check_name):
    #         #_log("× MISS[6] RecResourceSummary")

    # 7) Region | Reason
    v7 = build_region_reason_combo(meta_map)
    if v7:
        # if _trace_on(check_name):
        #     #_log("→ PICK[7] Region|Reason :", v7)
        return v7
    # else:
    #     if _trace_on(check_name):
    #         #_log("× MISS[7] Region|Reason")

    # 8) 전체 조합
    v8 = build_full_combo(meta_headers, meta_map)
    if v8:
        # if _trace_on(check_name):
        #     #_log("→ PICK[8] FullCombo :", v8)
        return v8

    # if _trace_on(check_name):
        #_log("→ PICK[?] EMPTY")
    # return ""

# ───────────────────────────────────────────────────────────────────────────── 끝
# 우선순위
# 우선순위
# 우선순위
# 우선순위
# 최종 표시 문자열 생성 — ★우선순위 체인 반영★
# 우선순위
# 우선순위
# 우선순위
# 우선순위
# ───────────────────────────────────────────────────────────────────────────── 끝










# ───────────────────────────────────────────────────────────────────────────── 시작
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# TA 결과 조회 : 상태 카운트 + (주의/경고)별 표시 문자열 목록
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# ───────────────────────────────────────────────────────────────────────────── 시작
def fetch_check_result_summary(
    support, check_id: str, meta_headers: List[str], check_name: str
) -> Tuple[int, int, int, int, str, Dict[str, List[str]]]:
    warn_count = 0
    error_count = 0
    ok_count = 0
    excluded_count = 0

    next_token = None
    result_status_raw = None
    status_to_texts: DefaultDict[str, List[str]] = defaultdict(list)

    while True:
        for attempt in range(6):
            try:
                kwargs = {"checkId": check_id, "language": LANGUAGE}
                if next_token:
                    kwargs["nextToken"] = next_token
                resp = support.describe_trusted_advisor_check_result(**kwargs)
                break
            except botocore.exceptions.ClientError as e:
                code = e.response.get("Error", {}).get("Code", "")
                if code in {"ThrottlingException", "TooManyRequestsException"}:
                    backoff_sleep(attempt)
                    continue
                raise

        result = resp.get("result", {}) or {}

        if result_status_raw is None:
            result_status_raw = (result.get("status") or "").lower().strip() or "not_available"

        flagged = result.get("flaggedResources") or []
        for r in flagged:
            st_raw = (r.get("status") or "").lower().strip()
            rid = _s(r.get("resourceId")).strip()
            is_suppressed = bool(r.get("isSuppressed"))
            meta_vals = [_s(v) for v in (r.get("metadata") or [])]

            # 이 구간 디버그용
            # 이 구간 디버그용
            #_debug_print_meta_for_rds_backups(check_name, meta_headers, meta_vals, rid, st_raw)
            # 이 구간 디버그용
            # 이 구간 디버그용

            display_text = compose_display(check_name, meta_headers, meta_vals, rid)

            if is_suppressed:
                excluded_count += 1

            if st_raw == "error":
                error_count += 1
            elif st_raw == "warning":
                warn_count += 1
            elif st_raw == "ok":
                ok_count += 1

            if (not is_suppressed) and display_text:
                if st_raw in ("ok", "warning", "error"):
                    status_to_texts[st_raw].append(display_text)

        next_token = resp.get("nextToken")
        if not next_token:
            break

    overall = STATUS_MAP_FINAL.get(result_status_raw, "미확인")
    return error_count, warn_count, ok_count, excluded_count, overall, status_to_texts

# ───────────────────────────────────────────────────────────────────────────── 끝
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# TA 결과 조회 : 상태 카운트 + (주의/경고)별 표시 문자열 목록
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# 상태 카운트
# ───────────────────────────────────────────────────────────────────────────── 끝
















# ───────────────────────────────────────────────────────────────────────────── 시작
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 문자열 유틸 및 "리소스 값" 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# ───────────────────────────────────────────────────────────────────────────── 시작
def split_on_commas(s: str) -> List[str]:
    s = _s(s)
    if not s:
        return []
    s = s.replace("，", ",").replace("\u00A0", " ")
    s = s.replace("\r\n", " ").replace("\r", " ").replace("\n", " ")
    parts = re.split(r",\s*", s)
    return [p.strip() for p in parts if p and p.strip()]

def explode_unique(items: List[str]) -> List[str]:
    seen = set()
    out: List[str] = []
    for s in items or []:
        toks = split_on_commas(s) if ("," in _s(s)) else [_s(s)]
        for tok in toks:
            tok = tok.strip()
            if tok and tok not in seen:
                seen.add(tok)
                out.append(tok)
    return out

def build_resource_value_cell(status_to_texts: Dict[str, List[str]]) -> str:
    lines: List[str] = []
    order = [("warning", "주의"), ("error", "경고")]  # 정상(ok) 제외
    for key, label in order:
        raw = status_to_texts.get(key, []) or []
        texts = explode_unique(raw)
        if not texts:
            continue
        lines.append(f"{label} :")
        lines.extend(texts)
    return "\n".join(lines)

# ── 소스 종류 판별 ──
SOURCE_RULES = [
    (re.compile(r"cost\s*optimization\s*hub", re.I), "AWS Cost Optimization Hub"),
    (re.compile(r"(?:compute|computer)\s*optimizer", re.I), "AWS Compute Optimizer"),
    (re.compile(r"\bconfig\b|aws\s*config|config\s*rule", re.I), "AWS Config"),
    (re.compile(r"well[-\s]?architected", re.I), "Well Architected 리뷰"),
    (re.compile(r"security\s*hub", re.I), "AWS Security hub"),
    (re.compile(r"\brds\b|amazon\s*rds", re.I), "Amazon RDS"),
]

def detect_source(name: str, description: str, category: str) -> str:
    blob = " ".join([(name or ""), (description or ""), (category or "")])
    for pat, label in SOURCE_RULES:
        if pat.search(blob):
            return label
    return "AWS Trusted Advisor"

def main():
    print(f"[INFO] Running file : {__file__}")
    print(f"[INFO] Script ver  : {VERSION}")

    support = session.client("support", region_name=SUPPORT_REGION)

    # 체크 메타데이터 조회
    try:
        resp = support.describe_trusted_advisor_checks(language=LANGUAGE)
        checks: List[dict] = resp.get("checks", []) or []
        print(f"[DEBUG] checks(en): {len(checks)}")
        if not checks and LANGUAGE.lower() != "ja":
            print("[WARN] No checks with LANGUAGE='en'. Retrying with LANGUAGE='ja' ...")
            resp = support.describe_trusted_advisor_checks(language="ja")
            checks = resp.get("checks", []) or []
            print(f"[DEBUG] checks(ja): {len(checks)}")
    except botocore.exceptions.ClientError as e:
        code = e.response.get("Error", {}).get("Code", "")
        if code in {"SubscriptionRequiredException", "AccessDeniedException"}:
            sys.stderr.write(
                "[에러] Trusted Advisor API 사용 권한/지원 플랜 부족.\n"
                " - Business/Enterprise/On-Ramp 지원 플랜 필요\n"
                " - 또는 aws-support 관련 권한 필요\n"
            )
        elif code == "UnhandledValidationException":
            sys.stderr.write("[에러] language 값은 'en' 또는 'ja'만 허용됩니다.\n")
        else:
            sys.stderr.write(f"[에러] API 호출 실패: {code}: {e}\n")
        sys.exit(1)
    except botocore.exceptions.NoCredentialsError:
        sys.stderr.write("[에러] 자격 증명을 찾을 수 없습니다.\n")
        sys.exit(1)

    # 비어 있어도 "헤더만 있는 엑셀" 생성
    if not checks:
        print("가져올 Trusted Advisor 체크가 없습니다. (헤더만 생성)")
        df_all = pd.DataFrame(columns=[
            "Check ID","Name","Category","Description",
            "경고(조치 권고)","주의(조사 권고)","정상(문제 없음)","제외",
            "최종 상태","리소스 값","소스 종류"
        ])
        with pd.ExcelWriter(OUTPUT_XLSX, engine="openpyxl") as xw:
            df_all.to_excel(xw, index=False, sheet_name="All")
            ws = xw.sheets["All"]
            for col_name, width in [("리소스 값", 80), ("최종 상태", 14), ("소스 종류", 28)]:
                if col_name in df_all.columns:
                    idx = df_all.columns.get_loc(col_name) + 1
                    ws.column_dimensions[get_column_letter(idx)].width = width
        print(f"완료: {OUTPUT_XLSX} (빈 결과, 헤더만)")
        return

    rows = []
    sample_preview = None

    for c in checks:
        check_id = c.get("id")
        check_name = c.get("name") or ""
        category = pretty_pillar_name(c.get("category"))
        description = (c.get("description") or "").strip()
        meta_headers = c.get("metadata") or []   # 메타데이터 헤더

        try:
            error_cnt, warn_cnt, ok_cnt, excl_cnt, overall, status_to_texts = (
                fetch_check_result_summary(support, check_id, meta_headers, check_name)
            )
        except botocore.exceptions.ClientError as e:
            sys.stderr.write(f"[경고] 체크 결과 조회 실패 ({check_id}, {check_name}): {e}\n")
            error_cnt = warn_cnt = ok_cnt = excl_cnt = 0
            overall = "미확인"
            status_to_texts = {}

        resource_value = build_resource_value_cell(status_to_texts)
        source_type = detect_source(name=check_name, description=description, category=category)

        if not sample_preview and resource_value:
            sample_preview = resource_value.replace("\n", "⏎")

        rows.append(
            {
                "Check ID": check_id,
                "Name": check_name,
                "Category": category,
                "Description": description,
                "경고(조치 권고)": error_cnt,
                "주의(조사 권고)": warn_cnt,
                "정상(문제 없음)": ok_cnt,
                "제외": excl_cnt,
                "최종 상태": overall,
                "리소스 값": resource_value,
                "소스 종류": source_type,
            }
        )

    df_all = pd.DataFrame(rows).sort_values(["Category", "Name"], ignore_index=True)

    with pd.ExcelWriter(OUTPUT_XLSX, engine="openpyxl") as xw:
        df_all.to_excel(xw, index=False, sheet_name="All")
        ws = xw.sheets["All"]

        if "리소스 값" in df_all.columns:
            col_idx = df_all.columns.get_loc("리소스 값") + 1
            ws.column_dimensions[get_column_letter(col_idx)].width = 80
            for row in range(2, ws.max_row + 1):
                cell = ws.cell(row=row, column=col_idx)
                cell.alignment = Alignment(wrap_text=True, vertical="top")

        if "최종 상태" in df_all.columns:
            col_idx = df_all.columns.get_loc("최종 상태") + 1
            ws.column_dimensions[get_column_letter(col_idx)].width = 14

        if "소스 종류" in df_all.columns:
            col_idx = df_all.columns.get_loc("소스 종류") + 1
            ws.column_dimensions[get_column_letter(col_idx)].width = 28

# ───────────────────────────────────────────────────────────────────────────── 끝
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 문자열 유틸 및 "리소스 값" 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# 리소스값 문자열 생성
# ───────────────────────────────────────────────────────────────────────────── 끝




# ───────────────────────────────────────────────────────────────────────────── 시작
# 콘솔 로그 결과값 멘트
# ───────────────────────────────────────────────────────────────────────────── 시작

    print(f"완료: {OUTPUT_XLSX} 생성 (All 시트)")
    if sample_preview:
        print(f"[PREVIEW] 첫 번째 '리소스 값' (개행표시=⏎): {sample_preview}")
    print(
        " - 새 우선순위 적용: Resource*값-일치확인(동일값은 패스) → Identifier/Name(헤더순서) → Instance(헤더순서,type/class제외) → Strong → 체크전용 → Recommended Summary → Region|Reason → 전체조합")
    print(" - 난수형 메타토큰/리전 단독/AZ/타입토큰(instance type/class 등)은 필터링")

    print(f"[INFO] Script version: {VERSION}")

if __name__ == "__main__":
    main()
